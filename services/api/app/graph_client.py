import os
import socket
from typing import List, Tuple, Dict, Any

# Try to import generated stubs; if not present, we’ll fall back.
try:
    import grpc  # type: ignore
    from app import graph_engine_pb2 as pb  # generated by Dockerfile step
    from app import graph_engine_pb2_grpc as pbg  # type: ignore
    HAVE_GRPC = True
except Exception:
    HAVE_GRPC = False
    pb = None
    pbg = None
    grpc = None


def check_graph() -> bool:
    """Quick TCP check to the engine container."""
    try:
        with socket.create_connection(("graph-engine", 50061), timeout=0.8):
            return True
    except Exception:
        return False


def _expand_via_stub(seed_ids: List[str]) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:
    """Local fallback so UI keeps working if gRPC isn’t ready or schema mismatches."""
    nodes = [
        {"id": "ent:TATA", "type": "entity", "attrs": {"name": "TATA"}},
        {"id": "ent:FOX", "type": "entity", "attrs": {"name": "Foxconn"}},
        {"id": "doc:1", "type": "doc", "attrs": {"title": "Doc 1"}},
    ]
    edges = [
        {"src": "ent:TATA", "dst": "doc:1", "type": "MENTION"},
        {"src": "ent:FOX",  "dst": "doc:1", "type": "MENTION"},
    ]
    if seed_ids and not any(s in {"ent:TATA", "ent:FOX", "doc:1"} for s in seed_ids):
        nodes = [{"id": seed_ids[0], "type": "entity", "attrs": {"name": seed_ids[0]}}]
        edges = []
    return nodes, edges


def _set_if_present(msg, field_name: str, value) -> None:
    """Set protobuf field only if it exists on the message type."""
    if hasattr(msg, "DESCRIPTOR") and field_name in msg.DESCRIPTOR.fields_by_name:
        setattr(msg, field_name, value)


def _find_expand_method_path() -> str | None:
    """
    Inspect the compiled proto descriptors to find the RPC whose request type is
    ExpandRequest and response type is ExpandResponse. Return the fully-qualified
    method path for grpc.channel.unary_unary: '/<service_full_name>/<method_name>'
    """
    if not hasattr(pb, "DESCRIPTOR"):
        return None

    # Find ExpandRequest / ExpandResponse message descriptors.
    msg_by_name = pb.DESCRIPTOR.message_types_by_name
    if "ExpandRequest" not in msg_by_name or "ExpandResponse" not in msg_by_name:
        return None
    req_desc = msg_by_name["ExpandRequest"]
    resp_desc = msg_by_name["ExpandResponse"]

    # Iterate services & methods to locate a matching RPC.
    for svc in pb.DESCRIPTOR.services_by_name.values():
        for m in svc.methods:
            if m.input_type is req_desc and m.output_type is resp_desc:
                # svc.full_name looks like 'graph.GraphEngine'
                return f"/{svc.full_name}/{m.name}"
    return None


def expand(
    seed_ids: List[str],
    max_hops: int = 2,
    window_days: int | None = 14,
    start_ms: int | None = None,   # ignored if engine doesn’t support it
    end_ms: int | None = None,     # ignored if engine doesn’t support it
) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:

    # If we don't have grpc or compiled stubs, return demo.
    if not HAVE_GRPC:
        return _expand_via_stub(seed_ids)

    # Build request safely.
    req = pb.ExpandRequest()  # type: ignore[attr-defined]
    if hasattr(req, "DESCRIPTOR"):
        # arrays
        if "seed_ids" in req.DESCRIPTOR.fields_by_name:
            getattr(req, "seed_ids").extend(seed_ids)
        # scalars
        _set_if_present(req, "max_hops", int(max_hops))
        if window_days is not None:
            _set_if_present(req, "window_days", int(window_days))
        if start_ms is not None:
            _set_if_present(req, "start_ms", int(start_ms))
        if end_ms is not None:
            _set_if_present(req, "end_ms", int(end_ms))

    # Resolve the RPC method path dynamically (works even if the generated Stub
    # method is named something else).
    method_path = _find_expand_method_path()
    if not method_path:
        # Couldn’t find a compatible RPC; keep UI alive.
        return _expand_via_stub(seed_ids)

    # Call the method directly through the channel.
    target = os.environ.get("GRAPH_ENGINE_ADDR", "graph-engine:50061")
    with grpc.insecure_channel(target) as ch:  # type: ignore
        call = ch.unary_unary(
            method_path,
            request_serializer=pb.ExpandRequest.SerializeToString,   # type: ignore
            response_deserializer=pb.ExpandResponse.FromString,      # type: ignore
        )
        try:
            resp = call(req, timeout=10.0)
        except Exception:
            # Engine not ready / RPC mismatch at runtime -> graceful fallback.
            return _expand_via_stub(seed_ids)

    # Convert response to our API shape, tolerating minor schema diffs.
    nodes: List[Dict[str, Any]] = []
    edges: List[Dict[str, Any]] = []

    for n in getattr(resp, "nodes", []):
        node = {
            "id": getattr(n, "id", ""),
            "type": getattr(n, "type", ""),
            "attrs": dict(getattr(n, "attrs", {})),
        }
        nodes.append(node)

    for e in getattr(resp, "edges", []):
        edge = {
            "src": getattr(e, "src", ""),
            "dst": getattr(e, "dst", ""),
            "type": getattr(e, "type", ""),
            "ts": getattr(e, "ts", None),
        }
        edges.append(edge)

    return nodes, edges
